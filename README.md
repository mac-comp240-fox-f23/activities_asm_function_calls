# Activity 16: Function Calls in Assembly
## Put your name(s) here

In this activity, you will explore in detail how function calls and returns are
implemented in assembly language. You will:
- Experiment with C code containing simple functions and trace how the calling and
called functions set up and use the program stack and registers
- Examine how multiple-file C programs are compiled together into one executable.
- Examine what happens when a function has more than 6 input arguments


## Provided Code

This activity focuses more on the `.d` files that are "lower-level" or more detailed
than the `.s` files generated by `gcc`. You start with:
- `Makefile`
    - a makefile to automate the compilation process
- `example1.c`
    - a C code containing a program with simple functions called by `main`
- `example2.c`
    - A C program with an example of a function with many inputs
- `incr.c`
    - A C code file that contains several functions that interact, optional to play with
-  `recurse.c`
    - A C code file containing a recursive function, optional to play with
- `multiple_files`
    - A folder containing a multifile program to illustrate how C combined code
    from different files
    - `Makefile`
        - A different makefile specific to this 3-file program
    -  `ms_main.c`
        - The main program, includes `mstore.h`
    - `mstore.h` and `mstore.c`
        - A helper code file and its header, includes `mult2.h`
    - `mult2.h` and `mult2.c`
        - A helper code file and its header

### Note about Makefiles

The main Makefile contains targets that produce the `.s` files as we have done before. It also
contains a target to produce the `.d` files from calling `objdump` on the executable. One
change is that it **keeps** the executable, so that you can run it and see that it works
correctly!

The subfolder `multiple_files` contains its own Makefile. This also uses `objdump` to 
generate assemby for the program from the executable. However, it is tailored to this
particular multifile program.

## Your Tasks

Before starting the tasks, examine the contents of the C code files and the Makefile. Make sure you understand what both are supposed to do.

### Task 1: Testing a simple program

- The file `example1.c` has a simple `main` function that calls a simple helper, `func1`.
- Use `make` to generate the `.d` and executable for this program
- Run the executable: does it produce what you expect?
- Examine the `.d` file
- With your teammates, talk through/diagram the changes to the program stack and registers
that happen up to the point when the call to `func1` returns.


### Task 2: Testing the book's example

- Create a new code file and copy the source code from the book's example (with `assign`, `adder`, and `main` functions) into the new code file
- Add to the Makefile so that it generates the `.d` file for this code as well as the executable
- Run the executable: do you get the **weird** result?
- If you haven't done so already, go through the book's example in detail, drawing the stack for each call. Use specific, if made-up, memory locations so that you can see exactly why the weird result happens

### Task 3: Examining multifile programs

Open the `multiple_files` folder, and read through the `.c` and `.h` files to be sure
you understand the code. Also, examine the `Makefile`and note how it differs from the main
one.

Separating this program into three code files is certainly overkill, but we are doing it
to examine how the C compiler produces assembly code for each file separately, and then
how that code is combined up to create a single executable. 

**When multiple files of code are used to compile one binary, the compiler will not be able to create one .s intermediate file from the original multiple files.**

The Makefile is set up with two special targets, `assembly` and `mstore-exe.d`. The first
target compiles all three `.c` files with that option `-S` that says to produce assembly.
The second target compiles all three `.c` files to generate an executable, then uses
`objdump` to disassemble it to get the final assembly for the whole program.

- Run `make` and note the results. In particular, notice that:
    - The `assembly` target doesn't make one `.s`file, it creates a separate file for each
    code file
    - The `mstore-exe.d` file contains the code from all three files


- Examine the four files. From the `mstore-exe.d` file, can you tell that the
code was originally in three separate files?

- Edit the `Makefile` and change the order of the `.c` files in the compiler 
command. Look at the resulting `.d`file. Does it differ from the previous one?
- Discuss what you have seen with your teammates, and put your observations here
in this README.


### Task 4: What if arguments need to go on the stack?

Because our assembly language sets aside 6 registers to hold arguments to a function,
it is unusual to have a function that must store its inputs on the stack. Nevertheless,
the compiler must allow for that to happen.

- Examine the program in `example2.c`, which includes a silly function that takes
in 9 inputes, as well as two sample calls in the `main` function.

- Use the Makefile to generate the `.d` file for this program
- Run the executable to make sure that it works
- Examine the assembly code in detail: with your partners draw pictures to show
what the stack and registers are doing:
    - Before `main` starts setting up for the function call
    - Just before the `callq` instruction is run
    - Just after the register values are added to the stack inside `func2`
    - Just after the function call returns
- Describe how/where extra input arguments are placed

### Optional Task 5: Check your by-hand work

If you get this far and have time, take the code examples from the by-hand parts
of this activity, or the examples from the book or my notes, and try them out. Make
sure the results make sense to you.

## References

- x86-64 jump instruction reference
    - [Steve Friedl's Intel x86 JUMP quick reference](http://unixwiz.net/techtips/x86-jumps.html)
- Assembly language resources (x86, 64-bit)
    - [x86 Assembly/X86 Instructions](http://en.wikibooks.org/wiki/X86_Assembly/X86_Instructions)
    - [X86 Opcode and Instruction Reference](http://ref.x86asm.net/coder64.html)
    - [x86 assembly language](http://en.wikipedia.org/wiki/X86_assembly_language)
    - [x86 instruction listings](http://en.wikipedia.org/wiki/X86_instruction_listings)
- gcc compiler flag references
    - [Compiler Option Summary](https://gcc.gnu.org/onlinedocs/gcc/Option-Summary.html)
    - [Index of gcc compiler options](https://gcc.gnu.org/onlinedocs/gcc/Option-Index.html)
- `objdump` resources
    - [Overview of the `objdump` command](https://www.thegeekstuff.com/2012/09/objdump-examples/)
- Makefile guides
  - [An Introduction to Makefiles](https://www.gnu.org/software/make/manual/html_node/Introduction.html), by GNU
  - [Makefile Tutorials and Examples to Build From](https://earthly.dev/blog/make-tutorial/), by Aniket Bhattacharyea
  - [makefile basics - anthony explains](https://www.youtube.com/watch?v=20GC9mYoFGs)
